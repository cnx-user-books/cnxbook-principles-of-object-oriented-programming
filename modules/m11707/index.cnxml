<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
	<title>Unit Testing with JUnit in DrJava</title>
	<metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>3ab9b0d4-1bdc-4c36-830d-a69ec8116737</md:uuid>
</metadata>
	<content>
		<para id="p10"><!-- -->			Object oriented systems derive great complexity through the interactions between the objects in the system.   It is often impossible to test the entire range of the total complex behavior that a system is designed to exhibit.   What one can say however is that if any given part of the system does not perform as desired, then one can make no assurances whatsoever about the integrity of the system as a whole.   Thus the testing of these smaller parts, or "units" is a crucial element of developing any large-scale OO system.  A <term>unit test</term> is a <emphasis>complete</emphasis> test of a small, atomic sub-system.  Note that this is <emphasis>not</emphasis> the same from a partial test of some aspect of the whole system! 
		</para>
		<para id="p20"><!-- -->
		Unit tests are often performed at the individual class level, meaning that a test class that runs all the complete battery of tests on the tested class, is written for each class to be tested.  In some cases however, certain systems of classes are not divisible into isolated, atomic units and in such must be tested as a whole.   The key is to test as small a piece of the system as possible and to test it as thoroughly as possible.
		</para>
		<section id="s10">
			<title>Using JUnit in DrJava</title>
			<para id="s10p10"><!--     --> Suppose we have a class such as the following that we wish to test.    Note that class is <code>public </code>and that the method we wish to test is also <code>public</code>.    <figure id="s10p10f10">
					<title>Sample Code To Be Tested</title>
					<media id="idm534736" alt=""><image src="../../media/test_class1.png" mime-type="image/png"/></media>
					<caption>Some example code to be tested.</caption>
				</figure>In DrJava, select "File/New JUnit Test Case...".   Enter a name that is descriptive of the test(s) you wish to make.   A recommendation is to use the class name being tested prepended with "<code>Test_</code>", such as "<code>Test_MyClass</code>".   This enables all your test classes to be easily identified,   DrJava will then automatically create a valid JUnit test class, such as below.   (Note that DrJava does not initially name the new class file, but the default name suggested by DrJava when you attempt to save it will be correct.)<figure id="s10p10f20">
					<title>Autogenerated Unit Test Class</title>
					<media id="idp1819536" alt=""><image src="../../media/unit_test1.png" mime-type="image/png"/></media>
					<caption>Test class autogenerated by DrJava.</caption>
				</figure></para>
			<para id="s10p20"><!-- --> Rename the auto-generated "<code>testX()</code>" method to something more descriptive of the particular test you'd like to perform.   The new name <emphasis>must</emphasis> start with "<code>test</code>" and <emphasis>must</emphasis> return <code>void </code>and take no input parameters.   You can create as many test methods as you wish to test your code.   JUnit will automatically run all methods that begin with "<code>test</code>" as test methods.  Typically, a single test method will test a single method on the class under test.   There are situations however where a single method under test may require several test methods to properly test its full range of operation.  In the code that follows, the <code>testX() </code>method has been renamed to "<code>test_myMethod1()</code>".   </para>
			<section id="s10s10">
				<title>assertEquals(...)</title>
				<para id="s10s1p10"><!-- -->
			There are a number of ways in which one can test that the proper result is produced.   The simplest method is to compare a single output value to an expected value.   For instance, suppose you are testing a method that returns a result.   One can compare the actual returned value to the value one expects for the given inputs.    There are two methods supplied by the junit.framework.TestCase class, which is the superclass of the test class generated by DrJava.   The first is <code>void assertEquals(String failResponse, Object actual, Object expected)</code>.    The actual input parameter is the actual result of the method under test.   The expected parameter is the expected result.  failResponse is a String that JUnit/DrJava will display if the actual value does not "equal" the expected value.    The <code>assertEquals(...)</code> method is overridden such that actual and expected values can be either Objects or primitives.   <code>assertEquals(...)</code> uses the <code>equals(...) </code>method of <code>Object</code> to makes it determination.   For primitives, the usual <code>==</code> is used.  For instance, we could write the test case below.   If the actual value does not equal the expected value, <code>assertEquals</code> throws a exception that is caught by the JUnit framework and an error message will result.   To test the code, first compile all the code then select the test class.  Right-click the test class and select "Test Current Document "or  click on "Tools/Test Current Document."   The following result will be displayed, given the test code we wrote to purposely fail: <figure orient="vertical" id="s10s10p10f10">
						<title>Using assertEquals(...) in a test case</title>
						<media id="idp2182000" alt=""><image src="../../media/unit_test2.png" mime-type="image/png"/></media>
						<caption><code>assertEquals(...)</code> displays the error string as well as comparative information if the <code>actual </code>and <code>expected </code>values are not equal.</caption>
					</figure></para><para id="s10s10p20"><!-- -->
			As shown on the screen shot, DrJava clearly indicates in red the test method that failed and the difference between the expected and actual values.    It also highlights the line of code in the test method where the failure occured.  </para>
				<para id="s10s10p30">There is one exception to the syntax of <code>assertEquals</code>, and that is when the values being compared are <code>doubles</code>.  <code/>This is because round-off errors in calculating floating point values means that it is almost always impossible to generate the same value from two different calculations, even if mathematically they are the same.   For instance, compate <code>2.3*2.3</code> and <code>5.29</code>.  Mathematically identical, but on a PC running Windows, Java calculates them to be different by approximately <code>0.00000000000000089 </code>(or <code>8.9e-16</code> in Java syntax).    Thus, if the expected and actual values are to be of type <code>double</code>, then a 4'th input parameter is required.   This last parameter is a tolerance value, a plus-or-minus amount within which one considers the expected and actual values to be equal.  For instance:  <code display="block" id="idm7332288">assertEquals("Testing doubles: 5.29 vs. 2.3*2.3", 5.29, 2.3*2.3, 9e-16);</code>should pass, but <code display="block" id="idm7169088">assertEquals("Testing doubles: 5.29 vs. 2.3*2.3", 5.29, 2.3*2.3, 8e-16);</code>should fail.   Note that the tolerance value should always be a <emphasis>positive </emphasis>value.</para>
			</section>
			<section id="s10s20">
				<title>assertTrue(...)</title>
				<para id="s10s20p10"><!-- -->
			Another method provided by <code>TestCase</code> is <code>void assertTrue(String failResponse, boolean result)</code>.   This is a simplified version of <code>assertEquals(...)</code> used when the result can be expressed as a <code>boolean</code> true or false.   Note that any test using <code>assertTrue</code> can also be written as <code>assertEquals(failResponse, result, true).</code>   For instance we could write another test method to test the <code>myMethod2() </code>method of <code>MyClass</code>.   The test class now has two test methods and JUnit will run both ot them when we click on "Test Current Document."  Here, the second test method passes as shown in green below.   The first method still fails and its error messages are still shown.   Clicking on the error message will highlight the line where the error occured.   Correcting the code in <code>myMethod1(...)</code> would result in all the test methods being listed in green with no error messages.
		<figure id="s10s20p10f10">
						<title>Using assertTrue(...) in a test method</title>
						<media id="idm6939696" alt=""><image src="../../media/unit_test3.png" mime-type="image/png"/></media>
						<caption><code>assertTrue(...)</code> is used in <code>test_myMethod2(...) </code>above and does not generate an error because it is executed with a boolean <code>true </code>value.</caption>
					</figure></para></section>
			<section id="s10s30">
				<title>fail(...)</title>
				<para id="s10s30p10"><!-- -->
			For more complex testing, <code>TestCase </code>provides the <code>void fail(String failResponse)</code> method.   Calling this method will immediately cause the test method to fail and the <code>failResponse</code> string will be displayed.    Since this method does not know the actual or expected results, the <code>failResponse</code> string should contain more detailed information about what exactly failed and how it failed.   In the next screen shot is an example of using <code>fail(...)</code> where the test code was written such that it would fail: <figure id="s10s30p10f10">
						<title>Using fail(...) in a test method</title>
						<media id="idm7911664" alt=""><image src="../../media/unit_test4.png" mime-type="image/png"/></media>
						<caption>The <code>fail(...)</code> method immediately throws an error exception when it is executed.</caption>
					</figure></para></section>
			<section id="s10s40">
				<title>Additional Capabilities</title>
				<para id="s10s40p10"><!-- -->
			Note that any test method can call other methods if needed .   This is useful when the testing procedure is complex and needs to be broken down into smaller pieces.   Do not name these helper methods starting with "test" or they will be run separately as test cases!    Using helper methods is also useful when certain types of tests are performed only under certain conditions.  <code>assertEquals(...)</code>, <code>assertTrue(...)</code> and <code>fail(...) </code>can be called from anywhere, but the DrJava will only highlight the line in the main test method that generated the error, i.e. the line that called the helper method.  It will not highlight the line in the helper method where the actual call to <code>assertEquals(...)</code>, <code>assertTrue(...)</code> or <code>fail(...)</code>was made.
		</para><para id="s10s40p20"><!-- -->
			Sometimes in complex testing scenarios, there is a significant amount of initialization work required to set up the system to be tested.   This is often the case when testing a system of interdependent objects where the entire system must be set up before any single object can be tested.   If the initialization code is the same for all the tests being conducted, the method <code>protected void setup()</code> can be declared and be used to execute the necessary initializations.   To insure "clean" test runs, JUnit/DrJava re-instantiates the test class before running each test method.   The <code>setup()</code> method, if it exists, is called before any test method is executed.    This means that the test class <emphasis>cannot </emphasis>utilize any internal field values that one test method modifies and another test method expects to use as modified.     
		</para><para id="s10s40p30"><!-- -->
			Likewise, in the event that after a test is run that significant amounts of common "clean-up" code is required, one can declare the method protected void <code>tearDown()</code>.   This method runs after each test method and is useful for insuring, for instance, that files and network connections are properly closed and thus keep them from interfering with other tests.
		<!-- --></para>
				<para id="s10s40p40"><!-- -->
			The help system in DrJava has more detailed information on testing with JUnit, including how to create a test suite of multiple tests.
		</para>
			</section>
		</section>
	</content>
</document>