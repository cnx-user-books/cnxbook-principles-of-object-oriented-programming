<document xmlns="http://cnx.rice.edu/cnxml">
	<title>Ballworld, inheritance-based</title>
	<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m11806</md:content-id>
  <md:title>Ballworld, inheritance-based</md:title>
  <md:abstract>The module uses the Ballworld program to demonstrate key ideas in abstract classes, polymorphism, inheritance and other coding techniques.   This module will focus on an inheritance-based architecture.</md:abstract>
  <md:uuid>d3df7d53-feb1-4110-a8ea-478f088f0450</md:uuid>
</metadata>
	<content>
		<para id="p10">In this module we will explore many OOP concepts by examining the program "Ballworld".   Download the code for Ballworld <link resource="">here</link> (<emphasis>Link Temporarily Disabled.</emphasis>  Please contact the authors for the code.). <figure id="p10f10">
		<title>UML class diagram of Ballworld</title>
		<media id="id1164267529769" alt=""><image src="../../media/uml-55ec.png" mime-type="image/png"/></media>
		<caption>Note the union design pattern w.r.t. <code>ABall </code>and its subclasses.</caption>
	</figure>To run Ballworld, load the files into DrJava and right-click the BallControl file.  Select "<foreign>Run Document's Main Method</foreign>"  to run the program.   From the command line, go to the uppermost Ballworld directory and compile all the files in both the directories ("<foreign>javac ballworld/*.java</foreign>"  and "<foreign>javac command/*.java</foreign>") and then run the program as such: "<foreign>java ballworld.BallControl</foreign>".   The <foreign>Make Ball</foreign> button creates an instance of whatever <code>ABall </code>class is typed into the text field on the left.  The "<foreign>Clear All</foreign>" button clears any balls off of the screen.</para>
		<para id="p20">In a nutshell, the way Ballworld works is akin to a flip-book animation:   The <code>BallControl </code>class contains a <code>Timer </code>that "ticks" every 50 milliseconds.   Every time the timer ticks, the panel in the <code>BallGUI  </code>upon which the balls are to be drawn is requested to repaint itself.    When the panel repaints, it also tells the <code>Dispatcher </code>to notify every <code>ABall </code>in the system to update itself.   When an <code>ABall </code>updates, it updates any internal values it has (its "state") such as its color, radius, and/or velocity.   It then moves its position by an amount corresponding to its velocity and draws ("paints") itself onto the panel.  Since this is happening 20 times a second, the balls appear to be moving and/or changing and thus the animation is acheived.    The <code>ILambda </code>interface3 enables the <code>BallGUI </code>to communicate in a generic, decoupled manner to the <code>BallControl </code>and the <code>Randomizer </code>class is a utility class that provides methods to produce various random values needed by the system.   Much of the code in Ballworld is significantly more sophisticated than what has been covered in the course so far--it will be covered soon, don't worry!</para>
		<section id="s10">
			<title>Abstract Classes</title>
			<para id="s10p10">First, we will focus on the union design pattern between <code>ABall</code>, <code>WanderBall</code>, <code>CurveBall </code>and <code>StraightBall</code>.   In a union design pattern, we see that the superclass represents an abstraction of the union of its subclasses.    For instance, a fruit is an abstraction of specific concrete classes such as apple and pear.   A fruit embodies the common characteristics of its subclasses even if it doesn't completely describe the exact nature of those characteristics.   In a fruit, there is a seed.   However, the notion of "fruit" doesn't specify exactly the number, size, color or shape of its seed(s).  It only specifies that it does indeed have a seed.    Likewise, a fruit has the behavior of ripening.   Apples, oranges, and bananas all ripen differently and at different rates.   The abstract fruit notion does not specify the specific nature of the ripening behavior, just simply that it does have that behavior.   In such, we see that we can never have a fruit that is not a specific class of fruit, such as an orange or  grape. </para>
			<para id="s10p20">Corresponding to the above notions, abstract classes in Java cannot be instantiated.    Abstract classes are denoted by the <code>abstract </code>keyword in the class definition: <code id="id1164264158974" display="block">
	public abstract class AFruit {...} </code> By convention, the classnames of abstract classes always begin with "A".  </para>
			<para id="s10p30">In Ballworld, <code>ABall </code>is an abstract class representing a circular ball that has a number of properties: a color, a position, a velocity, etc.  The abstract ball also has some defining behaviors, such as that all balls should paint a filled, colored circle when requested to display themselves on a graphics context (a panel).  Likewise all balls know how to bounce off the walls of the container.  These concrete behaviors are called "default behaviors" because all subclasses of <code>ABall</code>, such as <code>StraightBall </code>and <code>CurveBall</code>, automatically get these behaviors by default.    One of the most common and useful reasons for using an abstract class is to be able to define the default behaviors for all the subclasses.</para>
			<section id="s15">
				<title>Abstract Methods</title>
				<para id="s15p10">But what about the abstract behaviors that abstract classes exhibit?   For instance the abstract "ripening" behavior of a fruit?  At the abstraction level of a fruit, the exact implentation of ripening cannot be specified because it varies from one concrete subclass to another.  In Java, this is represented by using the keyword abstract as part of the signature of a method which has no code body:   <code id="id1164271201231" display="block">
	public abstract class AFruit {
		// rest of the code
		
		public abstract void ripen();
	}</code> There is no code body because it cannot be specified at this abstraction level.   All that the above code says is that the method does exist in all <code>AFruit</code>.     The specific implmentation of method is left to the subclasses, where the method is declared identically except for the lack of the <code>abstract </code>keyword:   <code id="id1972824" display="block">
	public class Mango extends AFruit { 
		// rest of code
		
		public void ripen() {
			// code to ripen a mango goes here
		}
	}
	
	public class Tomato extends AFruit {
		// rest of code
		
		public void ripend() {
			// code to ripen a tomato goes here
		}
	}</code>The technical term for this process is called <term>overriding</term>.   We say that the concrete methods in the subclasses <emphasis>override </emphasis>the abstract method in the superclass. </para>
				<para id="s15p15">Note that if a class has an abstract method, the class itself must be declared <code>abstract</code>.    This simply because the lack of code in the abstract method means that the class connot be instantiated, or perhaps more importantly, it says that in order for a class to represent abstract behavior, the class itsefl must represent an abstract notion.</para>
				<para id="s15p17"> Overriding is not limited to abstract methods.  One can override any concrete method not declared with the <code>final </code>keyword.    We will tend to avoid this technique however, as the changing of behavior as one changes abstraction levels leads to very unclear symantics of what the classes are actually doing.</para>
				<para id="s15p20">In Ballworld we see the abstract method <code>updateState</code>.   Abstract methods and classes are denoted in UML diagrams by italic lettering.  This method is called by the <code>update </code>method as part of the invariant process of updating the condition of the ball every 50 milliseconds.    The update method does 4 things: <list id="s15p20l10" list-type="enumerated">
						<item>Update the state of the ball by calling the abstract <code>updateState </code>method.</item>
						<item>Move (translate) the position of the ball by adding the velocity to it.</item>
						<item>Check if the ball needs to bound off a wall.</item>
						<item>Paint the ball up on the screen.</item>
					</list>This technique of calling an abstract method from inside of a concrete method is called the <emphasis>template method design pattern</emphasis>--which we will get to later in the course.</para>
				<para id="s15p30"><code>ABall.updateState()</code> is abstract because at the abstraction level of <code>ABall</code>, one only knows that the ball will definitely do something with regards to modifying (perhaps) its internal field values(its "state").  Each subclass will do it differently however.   The <code>StraightBall </code>will do nothing in its <code>updateState </code>method because a ball with a constant (unchanging) velocity will travel in a straight line.  Remember, <emphasis>doing nothing is doing something</emphasis>! The <code>CurveBall</code>'s <code>updateState </code>method uses sines and cosines to turn the velocity by a fixed (though randomly chosen) angle at every update event.   You can imagine that other possible subclassses could do things such as randomly change the velocity or change the radius of the ball or change the color of the ball.</para>
				<para id="s15p40">There is no code in the entire Ballworld system that explicitly references any of the concrete <code>ABall </code>subclasses.    All of the code runs at the level of abstraction of an abstract ball.  The differences in behavior of the various balls made on the screen using the different concrete subclasses is strictly due to <emphasis>polymorphism</emphasis>.  New  types of balls can be added to the system without recompiling <emphasis>any </emphasis>of the existing code.   In fact, new types of balls can be added without even stopping the Ballworld program!</para>
			</section>
		</section>
		<section id="s20">
			<title>Abstract classes vs. Interfaces</title>
			<para id="s20p10">Subclasses have a different relationship between interfaces and abstract superclasses.   A subclass that implements an interface is saying simply that it "acts like" that specified by the interface.    The class makes no statements however about fundamentally what it actually is.  An actor implements a fiercesome alien from a distant plantet in one movie and a fickle feline in another.   But an actor is actually neither.  Just because the actor protrayed a interplanetary alien, doesn't mean that the actor fundamentally possessed all the abilities of such an alien.  All it says is that in so far the context in which the actor was utilized as the alien, the actor did implement all the necessary behaviors of the alien.  </para>
			<para id="s20p20">A subclass is fundamentally an example of its superclass.   A subclass automatically contains all the behaviors of its superclass because it fundamentally <emphasis>is </emphasis>the superclass.    The subclass doesn't have to implement the behaviors of its superclass, it already has them.  An actor is a human and by that right, automatically possesses all that which makes a human:  one head, two arms, 10 toes, etc.  Note that this is true even if the abstract class has 100% abstract methods--it still enforces a strict taxonomical hierarchy.   <quote id="id1164267509393" display="block"><code>implements </code>is about <emphasis>behaving</emphasis>, <code>extends </code>is about <emphasis>being</emphasis>.</quote></para>
		</section>
		<section id="s25">
			<title>Variant vs. Invariant Behaviors</title>
			<para id="s25p10">A crucial observation is that the the Ballworld code that manages the GUI (<code>BallGUI</code>) and the ball management (<code>BallControl</code>, <code>Dispatcher</code>, etc.) only deal with the abstract ball, <code>ABall</code>.    That is, they represent <emphasis>invariant </emphasis>behavior at the abstract ball level.  The display, creation and managment of the balls is independent of the particular kinds of concrete balls that is being handled.   The main Ballworld framework can thus handle <emphasis>any </emphasis>type of <code>ABall</code>, past, present and future.     </para>
			<para id="s25p20"><code>StraightBall</code>, <code>CurveBall </code>and <code>WanderBall </code>are thus concrete variants of <code>ABall</code>.  They represent the <emphasis>variant </emphasis>behaviors of the system.   Other than in their constructors (which will prove to be a significant point when this inheritance-based model is compared to a more advanced composition-based model), these concrete subclasses only code the abstract variant behavior associated with a ball, namely the <code>updateState </code>method.  Inheritance gives any instantiation of these classes both the invariant behaviors from the <code>ABall </code>superclass plus the variant behaviors from the subclass.</para>
			<para id="s25p30">The Ballworld code demonstrates the importance of the concept of <term>separation of variant and invariant behaviors</term>.  <quote id="id1164267518318" display="block">Clearly and cleanly separating the variant and invariant behaviors in a program is crucial for achieving flexible, extensible, robust and correct program execution. </quote>  Where and how to separate the variant and invariant behaviors is arguably the most important design consideration made in writing god software. </para>
		</section>
		<section id="s30">
			<title>Java Syntax Issues</title>
			<section id="s30s10">
				<title>Packages</title>
				<para id="s30s10p10">Packages are way that Java organizes related classes together.   Packages are simply directories that contain the related code files.  Each class file in a package directory should have the line <code>package XXX; </code> at its top, where the <code>XXX </code>matches with the directory. name.   If neither <code>public </code>nor <code>private </code>(nor <code>protected</code> -- i.e. a blank specifier) is used to specify the visibility level of a class or method, then that method can be seen by other members of the package but not by those outside of the package.  To use the public classes in a package, the <code>import myPackage.*; </code> syntax is used.    This tells the Java compiler to allow all the public classes in the <code>myPackage </code>directory.   Packages can be nested,  though each level must be imported separately.</para>
			</section>
			<section id="s30s20">
				<title>Static fields and methods</title>
				<para id="s30s20p10">Static fields and methods, denoted by the <code>static </code>keyword in their declarations, are fields and methods that can be accessed at a class level, not just an object level.   In general these are values or behaviors that one wishes for all instances of a class to have access to.   These values and behaviors are necessarily independent of the state of any particular instance.   Static fields and methods are often referred to as "<emphasis>class variables</emphasis>"  and "<emphasis>class methods</emphasis>".    </para>
				<para id="s30s20p20">An examples of a class variables are <code>Math.PI</code> and <code>Color.BLUE</code> or <code>Color.RED</code>.    These are universal values associated with math and color respectively and thus do not need an object instance to be viable.   By convention, all static field names are in all capitol letters.   A static field is referenced simply by writing the class name  followied by a period and then by the field name.   No instantiations are necessary. </para>
				<para id="s30s20p30">The <code>Randomizer </code>class contains numerous static methods.  This is because each of the methods to produce various random values is independent of each other and that the process in each method does not affect nor is affected by the state of the rest of the class.   Essentially, this entails that the class contain no non-static fields.  A class as such is referred to as being "<emphasis>stateless</emphasis>".    Just like a static field, a static method is invoked in the same manner as the static fields:  <code>ClassName.staticMethodName(...) </code>  Classes with static methods are usually utility classes that are used to hold a set of related functional processes, e.g. <code>Randomizer </code>holds a collection of random value generators.   Likewise, <code>Math </code>holds a combination of static values, such as <code>PI </code>and static methods such as <code>sin</code>() and <code>cos</code>().</para>
				<para id="s30s20p40">There is one very special static method with the following <emphasis>exact </emphasis>signature:  <code id="id1164267627049" display="block">
	public static void main(String[] args) </code>
	This method, found in <code>BallControl</code>, is the method that Java uses to start programs up.   Since OO programs are systems of interacting objects, this static "main" method is used to create the first object(s) and get the program up and running.   So when Java starts a program, it looks for this and only this method.</para>
			</section>
			<section id="s30s30">
				<title>Calling methods of the superclass</title>
				<para id="s30s30p10">When concrete methods or the constructor of a superclass are overriden, sometimes it is necessary or desirable to call the original superclass behavior from the subclass.   A common reason for this is that the subclass's behavior is simple an addition to the superclass behavior.   One does not want to replicate the superclass code, so a call to the superclass's original methods is required at some point in the subclasses overriding method.   To accomplish this, Java uses the <code>super </code>keyword.  <code>super </code>refers to the superclass instance, just as <code>this </code>refers to the class instance itself (the subclass here).   Note that technically, <code>super </code>and <code>this </code>are the same object -- think of it as the difference between the <foreign>id </foreign>and the <foreign>ego</foreign>.  (Does that mean that a coding mistake wiith respect to <code>super </code>and <code>this </code>is a Freudian slip?) </para>
				<para id="s30s30p20">Suppose the superclass has a method called <code>myMethod()</code> which the subclass overides.   For the subclass to call the superclass's <code>myMethod</code>, it simply needs to say <code>super.myMethod()</code>.   Contrast this to the subclass calling its own <code>myMethod</code>:  <code>this.myMethod() </code> (note: Java syntax rules allow for the <code>this </code>to be omitted).  </para>
				<para id="s30s30p30">To make a call to the superclass's constructor the subclass simply says <code>super(...)</code>, supplying wahtever parameters the superclass constructor requires.  This is a very common scenario as the the subclass almost always needs to superclass to initialize itself before it can perform any additional initializations.    Thus the <code>super(...)</code> call must be the first line in the subclass's constructor.  If the no-parameter constructor of the superclass is required, the call to <code>super </code>can be omitted as it will be automatically performed by the Java run-time engine.   This of course presumes that the superclass's no-parameter constructor exists, which it does <emphasis>not </emphasis>if a parameterized constructor has been declared without explicitly declaring the no-parameter constructor.</para>
			</section>
		</section>
	</content>
</document>